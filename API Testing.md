# API Testing
- API Documentations written JSON, YAML or XML format. Also in some JavaScript files. Documents sometimes publicly available. You can find with BURP **INTRUDER**
      ```
      /api
      /swagger/index.html
      /openapi.json
      ```
- After Indentifying API endpoint find supported HTTP methods(change methods and find it).
- The endpoint /api/tasks may support the following methods: ```GET, PATCH(apply changes), OPTIONS(about request methods), POST, DELETE ```
- Identify supported Content Types : ```Content-Type: application/json ```

  ## Mass Assigment Vulns
- You can identify these hidden parameters by manually examining objects returned by the API. You can get it via GET /api/users/123
```
{
    "username": "wiener",
    "email": "wiener@example.com",
}
```
- Then PATCH  and get Admin privilege to John user
```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "true"
}
```
## Server-Side Parameter Pollutions
- Server-side parameter pollution occurs when a website embeds user input in a server-side request to an internal API without adequate encoding. Aattacker may get
      -Override existing parameters.
      - Modify the application behavior.
      - Access unauthorized data.

  - To test for server-side parameter pollution in the query string, place query syntax characters like #, &, and = in your input and observe how the application responds. DON'T FORGET TO ENCODE CHARACTERS
```
When you search for a user, your browser makes the following request:
GET /userSearch?name=peter&back=/home

To retrieve user information, the server queries an internal API with the following request:
GET /users/search?name=peter&publicProfile=true
```
- Injection invalid parameters
```
For example, you could modify the query string to the following:
GET /userSearch?name=peter%26foo=xyz&back=/home

This results in the following server-side request to the internal API:
GET /users/search?name=peter&foo=xyz&publicProfile=true
```
- Inject valid Parameters
```
For example, you could modify the query string to the following:
GET /userSearch?name=peter%26name=carlos&back=/home

This results in the following server-side request to the internal API:
GET /users/search?name=peter&name=carlos&publicProfile=true
```
- PHP parses the last parameter only.(carlos)
- ASP.NET combines both parameters.(peter,carlos and occur Invalid username error)
- Node.js / express parses the first parameter only. (peter unchanged result)

- LAB. Get Admins rights. Find **field* via intruder, find **reset_token* from JS files
```
username=administrator%26field=reset_token

```

## Possible pash traversal
- ```GET /api/private/users/peter``` use **peter/../admin** to path traversal attack
- 

## Preventing Vulnerabilities in APIs
- Secure your documentation if you don't intend your API to be publicly accessible.
- Ensure your documentation is kept up to date so that legitimate testers have full visibility of the API's attack surface.
- Apply an allowlist of permitted HTTP methods.
- Validate that the content type is expected for each request or response.
- Use generic error messages to avoid giving away information that may be useful for an attacker.
- Use protective measures on all versions of your API, not just the current production version.

  ## Preventing server-side parameter pollution
To prevent server-side parameter pollution, use an allowlist to define characters that don't need encoding, and make sure all other user input is encoded before 
it's included in a server-side request. You should also make sure that all input adheres to the expected format and structur
